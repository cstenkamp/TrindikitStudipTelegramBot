TODO
-ein "repeat"-kommando einbrigen mit dem es die letzte utterance wiederholt
-einen Telegram-Chatbot draus machen
-per CI den Chatbot automatisch auf meinen webspace committen
-Den IS (und den MIVS) statt per Pickle in ner Datenbank (->SQLAlchemy Object relational) speichern
-Sowohl Conversations (IS/MVIS) als auch Users (->gespeicherte commands) in separate Tables in ner Datenbank haben (user_db hat dann ein feld für die user-id, und ein feld für "current conversation/session"
#TODO you know what, ich speicher den Kram in ner Datenbank. ==> SQLAlchemy, die ibis-klasse extended Base=declarative_base(), und für die werte .IS und .MVIS gibt es entsprechungen
#TODO Flyweight-pattern nutzen, sodass jede ibis-instanz nur den Stand der Datenbank hat, und die Methoden von ner gemeinsamen erbt
-Sämtliche ICMs von https://pdfs.semanticscholar.org/0066/b5c5b49e1a7eb4ea95ee22984b695ec5d2c5.pdf benutzen, und bspw bei zu langer Wartezeit vom User 2 system responses machen können
-Dialog ist System-Antwort auf User-Nachricht, außerdem mixed initiative! Ein Event-System einführen wo das sytem schreiben kann!
-Information state approach erweiterung: Tentatively added stuff
-warum sind YNQs Props (brauchen im Konstruktor eine, und sind damit bereits vollwertige propositionen), während WhQs immer noch Pred1's sind? Warum nicht YNQs Pred1s über die Domain bool?
  -warum ist es YNQ(Prop((Pred0('return'), None, True))) und nicht YNQ(Pred0('return')) --> warum muss es nochmal in ner Prop sein wo noch Truth-value bei ist
  --> warum muss ein Pred0 den Umweg über Prop gehen?

DONE
-den IS bzw alle nötigen informationen speichern, sodass man die current session schließen kann und neu starten
-ein "exit"-kommando
-switch to python3
-man kann nein antworten (bug schon in original)


--------------
-Situation: Instanz der Klasse IBIS IST sowohl domain, HAT information state, HAT alle update rules als function, ...
->blöd, weil: nur für ein gespräch gleichzeitig.
==> IS auslagern.
====> Flyweight-pattern: Sämtliche Konversationen teilen sich funktionen, und nur Sachen wie IS sind einzen
further: use databases.
nen telegram-bot wartet auf messages. Sobald er eine kriegt, steht dabei von welchem User.

Problem: Das beispiel von hier hat IS nur im RAM.
Wenn, mit supervielen Usern wie in telegram, ein gespräch über mehrere tage geht, müssten zig instanzen gleichzeitig aktiv sein.
Tausend gespräche im RAM = 1000 instanzen der Klasse IBIS, die sehr viel RAM verbrauchen, und die auch irgendwie alle nen einzelnen Thread brauchen und alles?
Wie ist ein telegram gespräch denn sonst? Nachricht -> Antwort. Soll heißen: alles ist nur in ner datenbank gespeichert, wenn user X eine nachricht schreibt wird der IS von diesem User aus der Datenbank geladen, ne antwort generiert, updates in der DB gespeichert, session ende.

lazy writing nutzen: 5 minuten nach antwort das gespräch noch im RAM halten, sodass man den IS jetzt nehmen kann statt aus der DB zu laden

--> alles textuell speichern, und drauf achten dass in der DB dann alle und nur alle sachen sind die einer konversation eigen sind